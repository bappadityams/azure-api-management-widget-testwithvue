{"version":3,"file":"deploy.js","sourceRoot":"","sources":["../../../src/node/deploy.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,uBAAmC,MAAM,2BAA2B,CAAC;AAC5E,OAAO,EAAE,qBAAqB,EAAE,MAAM,UAAU,CAAC;AACjD,OAAO,EAAE,MAAM,IAAI,CAAC;AACpB,OAAO,gBAAgB,MAAM,oBAAoB,CAAC;AAClD,OAAO,OAAO,MAAM,WAAW,CAAC;AAehC;;;;;;;GAOG;AACH,KAAK,UAAU,MAAM,CACnB,kBAAsC,EACtC,IAAY,EACZ,kBAAkB,GAAG,WAAW,GAAG,qBAAqB,EACxD,YAAoB,SAAS;IAE7B,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACpB,OAAO,CAAC,GAAG,CAAC,4CAA4C,GAAG,IAAI,CAAC,CAAC;IACjE,OAAO,CAAC,GAAG,CAAC,uDAAuD,CAAC,CAAC;IAErE,MAAM,cAAc,GAAG,MAAM,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;IAClE,MAAM,uBAAuB,GAAG,IAAI,uBAAuB,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IAElF,IAAI,MAA0B,CAAC;IAC/B,IAAI;QACF,OAAO,CAAC,GAAG,CAAC,mDAAmD,CAAC,CAAC;QACjE,MAAM,GAAG,MAAM,uBAAuB,CAAC,SAAS,EAAE,CAAC;KACpD;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;KAClC;IACD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,CAAC,GAAG,CAAC,sCAAsC,GAAG,kBAAkB,CAAC,CAAC;QACzE,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,YAAY,CAAC,kBAAkB,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;KACrE;IACD,IAAI,CAAC,MAAM,EAAE;QACX,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;KACrD;IAED,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;IAEpC,MAAM,KAAK,GAAG,OAAO,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;IAErC,OAAO,CAAC,GAAG,CAAC,0CAA0C,GAAG,SAAS,GAAG,YAAY,CAAC,CAAC;IAEnF,MAAM,uBAAuB,CAAC,YAAY,EAAE,CAAC;IAE7C,MAAM,QAAQ,GAAoB,EAAE,CAAC;IACrC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACrB,MAAM,OAAO,GAAG,EAAE,CAAC,YAAY,CAAC,SAAS,GAAG,IAAI,CAAC,CAAC;QAClD,MAAM,OAAO,GAAG,uBAAuB;aACpC,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC;aACnC,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB,GAAG,IAAI,CAAC,CAAC,CAAC;QACrD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IACH,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAE5B,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,4BAA4B,CAAC,CAAC;IAEzD,MAAM,CAAC,UAAU,GAAG,IAAI,IAAI,EAAE,CAAC;IAC/B,MAAM,uBAAuB,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACnD,OAAO,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAC;AACzC,CAAC;AAED,eAAe,MAAM,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport CustomWidgetBlobService, { Config } from \"./CustomWidgetBlobService\";\nimport { APIM_CONFIG_FILE_NAME } from \"../paths\";\nimport fs from \"fs\";\nimport getStorageSasUrl from \"./getStorageSasUrl\";\nimport readdir from \"./readdir\";\n\n/**\n * resourceId - resource ID of API Management service \"subscriptions/[subscription-id]/resourceGroups/[resource-group-name]/providers/Microsoft.ApiManagement/service/[service-name]\"\n * managementApiEndpoint - URL with protocol (e.g. https://management.azure.com)\n * apiVersion - optional to override default (e.g. \"2019-01-01\")\n * tokenOverride - optional, provides token to use for auth, instead of 'az login' approach\n */\nexport type ServiceInformation = {\n  resourceId: string;\n  managementApiEndpoint: string;\n  apiVersion?: string;\n  tokenOverride?: string;\n};\n\n/**\n * Deploys everything from /dist folder to the API Management DevPortals' blob storage.\n *\n * @param serviceInformation - service information for deployment\n * @param name - name of the widget to be deployed\n * @param fallbackConfigPath - local path to the config file (by default \"./static/config.msapim.json\")\n * @param rootLocal - optional, root of the local folder with compiled project to be exported (by default \"./dist\")\n */\nasync function deploy(\n  serviceInformation: ServiceInformation,\n  name: string,\n  fallbackConfigPath = \"./static/\" + APIM_CONFIG_FILE_NAME,\n  rootLocal: string = \"./dist/\"\n): Promise<void> {\n  console.log(\"\\n\\n\");\n  console.log(\"Starting deploy process of custom widget: \" + name);\n  console.log(\"Please, sign in to your Azure account when prompted\\n\");\n\n  const blobStorageUrl = await getStorageSasUrl(serviceInformation);\n  const customWidgetBlobService = new CustomWidgetBlobService(blobStorageUrl, name);\n\n  let config: Config | undefined;\n  try {\n    console.log(\"Looking for config file in the Azure blob storage\");\n    config = await customWidgetBlobService.getConfig();\n  } catch (e) {\n    console.log(\"Config not found.\");\n  }\n  if (!config) {\n    console.log(\"Looking for a local config file in: \" + fallbackConfigPath);\n    config = JSON.parse(fs.readFileSync(fallbackConfigPath).toString());\n  }\n  if (!config) {\n    throw new Error(\"Config file could not be loaded.\");\n  }\n\n  console.log(\"Config file loaded\\n\");\n\n  const files = readdir(\"\", rootLocal);\n\n  console.log(\"Starting upload of data files from the '\" + rootLocal + \"' folder\\n\");\n\n  await customWidgetBlobService.cleanDataDir();\n\n  const promises: Promise<void>[] = [];\n  files.forEach((file) => {\n    const content = fs.readFileSync(rootLocal + file);\n    const promise = customWidgetBlobService\n      .uploadWidgetDataFile(file, content)\n      .then(() => console.log(\"Uploaded file: \" + file));\n    promises.push(promise);\n  });\n  await Promise.all(promises);\n\n  console.log(files.length + \" files has been uploaded\\n\");\n\n  config.deployedOn = new Date();\n  await customWidgetBlobService.uploadConfig(config);\n  console.log(\"Uploaded updated config\");\n}\n\nexport default deploy;\n"]}