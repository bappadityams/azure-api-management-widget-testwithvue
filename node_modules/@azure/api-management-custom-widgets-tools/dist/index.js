'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var storageBlob = require('@azure/storage-blob');
var mime = require('mime');
var fs = require('fs');
var identity = require('@azure/identity');
var coreClient = require('@azure-rest/core-client');
var path = require('path');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var mime__default = /*#__PURE__*/_interopDefaultLegacy(mime);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Key for a search param, from which editor data will be loaded from.
 */
const APIM_EDITOR_DATA_KEY = "editorData";
/**
 * Key for a post message object, it's used to propagate changes from editor to the DevPortal. Used to prevent interference with other applications.
 */
const APIM_ON_CHANGE_MESSAGE_KEY = "customInputValueChangedMSAPIM";
/**
 * Key for a post message object, it's used to request and send secrets - token and user id, from the DevPortal. Used to prevent interference with other applications.
 */
const APIM_ASK_FOR_SECRETS_MESSAGE_KEY = "askForSecretsMSAPIM";
function parseWidgetData(urlSearchParams) {
    var _a;
    try {
        const urlEditorParams = JSON.parse(decodeURIComponent((_a = urlSearchParams.get(APIM_EDITOR_DATA_KEY)) !== null && _a !== void 0 ? _a : ""));
        // if (!("origin" in urlEditorParams)) {
        //   console.error(
        //     "Could not get 'origin' from the search params of the URL:\n" + self.location.href
        //   );
        // }
        return urlEditorParams;
    }
    catch (e) {
        console.error(`Could not get '${APIM_EDITOR_DATA_KEY}' from the search params of the URL:\n` +
            self.location, e);
        return { values: {}, environment: "error", instanceId: "error" };
    }
}
function getWidgetDataPure(urlSearchParams) {
    return parseWidgetData(urlSearchParams);
}
/**
 * Function to get all data related to the widget including technical values not expected to be needed in most cases.
 * Intended mostly for internal use, API might change. Consider using getValues or getEditorValues instead.
 */
function getWidgetData() {
    return getWidgetDataPure(new URLSearchParams(self.location.search));
}
function getEditorValuesPure(urlSearchParams) {
    return getWidgetDataPure(urlSearchParams).values;
}
/**
 * Function to get values you've set in the admin editor window.
 */
function getEditorValues() {
    return getEditorValuesPure(new URLSearchParams(self.location.search));
}
function getValuesPure(valuesDefault, urlSearchParams) {
    const values = Object.assign({}, valuesDefault); // set Obj to contain all possible values and prefill default value
    const urlValues = parseWidgetData(urlSearchParams).values;
    Object.keys(values).forEach((key) => {
        const value = urlValues[key];
        if (value != null && value !== "")
            values[key] = value; // if value is specified in the URL, replace the default value
    });
    return values;
}
/**
 * Function to get values you've set in the admin editor window. Undefined/empty values are replaced with default values.
 *
 * @param valuesDefault - object with your default values to use, just import valuesDefault object from values.ts folder
 */
function getValues(valuesDefault) {
    return getValuesPure(valuesDefault, new URLSearchParams(self.location.search));
}
/**
 * The onChange function itself with 'origin' provided as a param.
 *
 * @param origin - web content's origin (URL) of your Dev Portal to send changes to
 * @param instanceId - ID of this particular instance of the widget
 * @param values - values that changed
 */
function onChangeWithOrigin(origin, instanceId, values) {
    Object.entries(values).forEach(([key, value]) => {
        self.parent.postMessage({ [APIM_ON_CHANGE_MESSAGE_KEY]: { key, value, instanceId } }, origin);
    });
}
/**
 * Build onChange function, which you can use, to send changed data from the editor.
 */
function buildOnChange() {
    const { instanceId } = getWidgetData();
    return (values) => onChangeWithOrigin("*", instanceId, values);
}
/**
 * Request secrets - token & userId, from the Dev portal parent window.
 *
 * @param targetModule - is the function invoke from the main "app" window or the admin "editor"?
 */
async function askForSecrets(targetModule) {
    let receiveSecrets;
    const promise = new Promise((resolve, reject) => {
        const { instanceId, environment } = getWidgetData();
        receiveSecrets = ({ data }) => {
            if (!(APIM_ASK_FOR_SECRETS_MESSAGE_KEY in data))
                return;
            const secrets = data[APIM_ASK_FOR_SECRETS_MESSAGE_KEY];
            if (typeof secrets !== "object" || !("managementApiUrl" in secrets)) {
                reject("Secrets send by Dev Portal are invalid");
            }
            resolve(secrets);
        };
        self.addEventListener("message", receiveSecrets);
        const message = {
            [APIM_ASK_FOR_SECRETS_MESSAGE_KEY]: {
                instanceId,
                origin: self.location.origin,
                targetModule,
            },
        };
        if (targetModule === "app" && environment === "development") {
            self.parent.parent.postMessage(message, "*");
        }
        else {
            self.parent.postMessage(message, "*");
        }
    });
    return promise.finally(() => self.removeEventListener("message", receiveSecrets));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** root of the blob storage folder */
const BLOB_ROOT = "custom-widgets";
/** name of the blob storage folder with widget implementation */
const BLOB_DATA_FOLDER = "data";
/** name of the blob storage folder with widget configs */
const BLOB_CONFIGS_FOLDER = "configs";
/** name of the configuration file */
const APIM_CONFIG_FILE_NAME = "config.msapim.json";
/**
 * Generate relative path for widgets' data on the blob storage
 *
 * @param name - name of the widget
 */
function buildBlobDataPath(name) {
    return `${BLOB_ROOT}/${BLOB_DATA_FOLDER}/${name}/`;
}
/**
 * Generate relative path for widgets' config on the blob storage
 *
 * @param name - name of the widget
 */
function buildBlobConfigPath(name) {
    return `${BLOB_ROOT}/${BLOB_CONFIGS_FOLDER}/${name}/${APIM_CONFIG_FILE_NAME}`;
}

// Copyright (c) Microsoft Corporation.
/**
 * A service wrapping ContainerClient class to simplify blob handling
 */
class CustomWidgetBlobService {
    /**
     * @param blobStorageUrl - blob storage SAS URL
     * @param name - name of the custom widget to be taken care of
     */
    constructor(blobStorageUrl, name) {
        const container = "content";
        const blobServiceClient = new storageBlob.BlobServiceClient(blobStorageUrl.replace(`/${container}`, ""));
        this.containerClient = blobServiceClient.getContainerClient(container);
        this.name = name;
        this.pathWidget = buildBlobDataPath(name);
        this.pathConfig = buildBlobConfigPath(name);
    }
    extractFileName(path) {
        return path.split("/").pop();
    }
    async blobUpload(absolutePath, content) {
        const fileName = this.extractFileName(absolutePath);
        if (!fileName)
            throw new Error("a fileName was not found in the absolutePath");
        return this.containerClient.getBlockBlobClient(absolutePath).upload(content, content.length, {
            blobHTTPHeaders: { blobContentType: mime__default["default"].getType(fileName) || "application/octet-stream" },
        });
    }
    async jsonUpload(absolutePath, json) {
        return this.blobUpload(absolutePath, Buffer.from(JSON.stringify(json)));
    }
    async blobDownload(absolutePath) {
        return this.containerClient.getBlockBlobClient(absolutePath).downloadToBuffer();
    }
    async dirDelete(absolutePath) {
        var e_1, _a;
        try {
            for (var _b = tslib.__asyncValues(await this.containerClient.listBlobsFlat({ prefix: absolutePath })), _c; _c = await _b.next(), !_c.done;) {
                const blob = _c.value;
                await this.containerClient.deleteBlob(blob.name);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    async uploadWidgetDataFile(file, content) {
        return this.blobUpload(this.pathWidget + file, content);
    }
    async cleanDataDir() {
        return this.dirDelete(this.pathWidget);
    }
    async getConfig() {
        const buffer = await this.blobDownload(this.pathConfig);
        return JSON.parse(buffer.toString());
    }
    async uploadConfig(config) {
        return this.jsonUpload(this.pathConfig, config);
    }
}
var CustomWidgetBlobService$1 = CustomWidgetBlobService;

// Copyright (c) Microsoft Corporation.
async function getAccessToken(managementApiEndpoint) {
    const credentials = new identity.InteractiveBrowserCredential();
    const scope = `${managementApiEndpoint}/user_impersonation`;
    const { token } = await credentials.getToken(scope);
    return `Bearer ${token}`;
}
/**
 * Function to get storage SAS URL.
 *
 * @returns storage SAS URL
 */
async function getStorageSasUrl({ managementApiEndpoint, resourceId, apiVersion = "2019-01-01", tokenOverride, }) {
    var _a;
    const httpClient = coreClient.getClient(`${managementApiEndpoint}/${resourceId}`, { apiVersion });
    const response = await httpClient
        .pathUnchecked(`/portalSettings/mediaContent/listSecrets?apiVersion=${apiVersion}`) // TODO
        .post({
        headers: {
            "If-Match": "*",
            "Content-Type": "application/json",
            Authorization: tokenOverride !== null && tokenOverride !== void 0 ? tokenOverride : (await getAccessToken(managementApiEndpoint)),
        },
    });
    if (!((_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.containerSasUrl))
        throw new Error("Could not get storage SAS URL");
    return response.body.containerSasUrl;
}

// Copyright (c) Microsoft Corporation.
function readdir(dir, root) {
    const results = [];
    fs__default["default"].readdirSync(root + dir).forEach((file) => {
        const stat = fs__default["default"].statSync(root + dir + path__default["default"].sep + file);
        if (stat && stat.isDirectory()) {
            results.push(...readdir(dir + file + path__default["default"].sep, root));
        }
        else {
            results.push(dir + file);
        }
    });
    return results;
}

// Copyright (c) Microsoft Corporation.
/**
 * Deploys everything from /dist folder to the API Management DevPortals' blob storage.
 *
 * @param serviceInformation - service information for deployment
 * @param name - name of the widget to be deployed
 * @param fallbackConfigPath - local path to the config file (by default "./static/config.msapim.json")
 * @param rootLocal - optional, root of the local folder with compiled project to be exported (by default "./dist")
 */
async function deploy(serviceInformation, name, fallbackConfigPath = "./static/" + APIM_CONFIG_FILE_NAME, rootLocal = "./dist/") {
    console.log("\n\n");
    console.log("Starting deploy process of custom widget: " + name);
    console.log("Please, sign in to your Azure account when prompted\n");
    const blobStorageUrl = await getStorageSasUrl(serviceInformation);
    const customWidgetBlobService = new CustomWidgetBlobService$1(blobStorageUrl, name);
    let config;
    try {
        console.log("Looking for config file in the Azure blob storage");
        config = await customWidgetBlobService.getConfig();
    }
    catch (e) {
        console.log("Config not found.");
    }
    if (!config) {
        console.log("Looking for a local config file in: " + fallbackConfigPath);
        config = JSON.parse(fs__default["default"].readFileSync(fallbackConfigPath).toString());
    }
    if (!config) {
        throw new Error("Config file could not be loaded.");
    }
    console.log("Config file loaded\n");
    const files = readdir("", rootLocal);
    console.log("Starting upload of data files from the '" + rootLocal + "' folder\n");
    await customWidgetBlobService.cleanDataDir();
    const promises = [];
    files.forEach((file) => {
        const content = fs__default["default"].readFileSync(rootLocal + file);
        const promise = customWidgetBlobService
            .uploadWidgetDataFile(file, content)
            .then(() => console.log("Uploaded file: " + file));
        promises.push(promise);
    });
    await Promise.all(promises);
    console.log(files.length + " files has been uploaded\n");
    config.deployedOn = new Date();
    await customWidgetBlobService.uploadConfig(config);
    console.log("Uploaded updated config");
}

exports.APIM_ASK_FOR_SECRETS_MESSAGE_KEY = APIM_ASK_FOR_SECRETS_MESSAGE_KEY;
exports.APIM_CONFIG_FILE_NAME = APIM_CONFIG_FILE_NAME;
exports.APIM_EDITOR_DATA_KEY = APIM_EDITOR_DATA_KEY;
exports.APIM_ON_CHANGE_MESSAGE_KEY = APIM_ON_CHANGE_MESSAGE_KEY;
exports.BLOB_CONFIGS_FOLDER = BLOB_CONFIGS_FOLDER;
exports.BLOB_DATA_FOLDER = BLOB_DATA_FOLDER;
exports.BLOB_ROOT = BLOB_ROOT;
exports.askForSecrets = askForSecrets;
exports.buildBlobConfigPath = buildBlobConfigPath;
exports.buildBlobDataPath = buildBlobDataPath;
exports.buildOnChange = buildOnChange;
exports.deployNodeJS = deploy;
exports.getEditorValues = getEditorValues;
exports.getValues = getValues;
exports.getWidgetData = getWidgetData;
exports.onChangeWithOrigin = onChangeWithOrigin;
//# sourceMappingURL=index.js.map
