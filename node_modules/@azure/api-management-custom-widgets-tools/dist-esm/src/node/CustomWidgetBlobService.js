// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { BlobServiceClient } from "@azure/storage-blob";
import { buildBlobConfigPath, buildBlobDataPath } from "../paths";
import mime from "mime";
/**
 * A service wrapping ContainerClient class to simplify blob handling
 */
export class CustomWidgetBlobService {
    /**
     * @param blobStorageUrl - blob storage SAS URL
     * @param name - name of the custom widget to be taken care of
     */
    constructor(blobStorageUrl, name) {
        const container = "content";
        const blobServiceClient = new BlobServiceClient(blobStorageUrl.replace(`/${container}`, ""));
        this.containerClient = blobServiceClient.getContainerClient(container);
        this.name = name;
        this.pathWidget = buildBlobDataPath(name);
        this.pathConfig = buildBlobConfigPath(name);
    }
    extractFileName(path) {
        return path.split("/").pop();
    }
    async blobUpload(absolutePath, content) {
        const fileName = this.extractFileName(absolutePath);
        if (!fileName)
            throw new Error("a fileName was not found in the absolutePath");
        return this.containerClient.getBlockBlobClient(absolutePath).upload(content, content.length, {
            blobHTTPHeaders: { blobContentType: mime.getType(fileName) || "application/octet-stream" },
        });
    }
    async jsonUpload(absolutePath, json) {
        return this.blobUpload(absolutePath, Buffer.from(JSON.stringify(json)));
    }
    async blobDownload(absolutePath) {
        return this.containerClient.getBlockBlobClient(absolutePath).downloadToBuffer();
    }
    async dirDelete(absolutePath) {
        var e_1, _a;
        try {
            for (var _b = __asyncValues(await this.containerClient.listBlobsFlat({ prefix: absolutePath })), _c; _c = await _b.next(), !_c.done;) {
                const blob = _c.value;
                await this.containerClient.deleteBlob(blob.name);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    async uploadWidgetDataFile(file, content) {
        return this.blobUpload(this.pathWidget + file, content);
    }
    async cleanDataDir() {
        return this.dirDelete(this.pathWidget);
    }
    async getConfig() {
        const buffer = await this.blobDownload(this.pathConfig);
        return JSON.parse(buffer.toString());
    }
    async uploadConfig(config) {
        return this.jsonUpload(this.pathConfig, config);
    }
}
export default CustomWidgetBlobService;
//# sourceMappingURL=CustomWidgetBlobService.js.map